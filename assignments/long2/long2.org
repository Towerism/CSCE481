#+TITLE: Long Assignment 2
#+AUTHOR: Martin Fracker
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \bibliographystyle{alphadin}
#+LATEX_HEADER: \input{titlepage}

* Introduction
Ruby Args cite:argsgit is a small library written by Robert Martin to complement
the java version of the same library which he used as a case study of
test-driven development in his book /Clean Code: A Handbook of Agile Software
Craftsmanship/ cite:cleancode.
* Project Structure
The Ruby Args project consists of two main source files: =args_spec.rb=, and
=args.rb=. There is another file, =Main.rb=, which serves as a demonstration of
the usage of Ruby Args, but reading =args_spec.rb=, which describes the business
logic of Ruby Args, should be sufficient enough to get a crisp understanding of
how to use the library.

The file =args.rb= is the primary file in the project as it contains the logic
for the entire library. It contains a single =Args= class which contains the
nested classes: =Parser=, =BoolMarshaler=, =NumberMarshaler=, =StringMarshaler=,
and =NumberListMarshaler=.
* Library Explanation
Ruby Args parses command line interface (CLI) arguments passed in at invocation
given a specification of expected arguments and argument types. Note that for
the remainder of this document, =Class.method= will refer to a static method,
and =Class#method= will refer to an instance method.
** Usage label:usage
The user should instantiate a parser by declaring the expected arguments using
=Args.expect=. See ref:ioexpect for a more in-depth explanation of the expected
input for =Args.expect=.
#+BEGIN_SRC ruby
  parser = Args.expect do
    string "f"
  end
#+END_SRC

Given an instance of the =Parser= class, the user can simply call the
=Parser#parse= method in order to parse the CLI arguments. Then, the user can
access the value of each argument using the =Parser#[]= operator.
#+BEGIN_SRC ruby
  parser.parse(ARGV)
  file = parser["f"]
#+END_SRC

After parsing, the user can use =Parser#valid?= to check if parsing was
successful. See ref:ioparse for a more in-depth explanation of the input and output
of =Parser#parse=.
#+BEGIN_SRC ruby
  if not parser.valid?
    puts = "Usage: <Program> [f <file>]"
  end
#+END_SRC
** I/O Specification 
This section will describe the business logic of the library in
more detail.
*** =Args#expect= label:ioexpect
The user calls this method to specify what arguments the parser should
expect. See ref:usage for an example of an argument declaration being passed to
=Args#expect=.
**** Input
The user should pass in a block containing any number of statements each
declaring any number of comma-separated argument names which will be of one
particular type: =boolean=, =number=, =string=, or =number_list=. An example of
such a block is
#+BEGIN_SRC ruby
  do
    boolean "v,s"
    number "n,p"
    string "d"
    number_list "a"
  end
#+END_SRC
which, when passed to to =Args#expect=, would declare the arguments =v=, =s=,
=n=, =p=, =d=, and =a=, each with a type corresponding to its declaration.
**** Output
A parser expecting the declared arguments will be returned. Note that, if an
empty block was passed in, a parser expecting zero arguments will be returned.
*** =Parser#parse= label:ioparse
The user calls this method to parse an array of CLI arguments according to the
expected arguments. See ref:usage for an example of how to declare the expected
arguments.
**** Input
The user should pass in an array containing the CLI arguments. Each argument
name should start with a dash, and the values associated with each argument
should follow the argument's name in the array.

Note that boolean arguments act as switches and should not carry with them any
value, and the value of a number list argument should be a comma-separated list
of numbers. If spaces are preferred after each comma, then the whole number list
should be surrounded by quotes.

Examples of valid CLI input, assuming that =b= is a boolean, =n= is a number,
=l= is a number list, and =s= is a string, are
#+BEGIN_SRC
  -b -n 50 -l 2,4,6 -s text
  -b -n 50 -l "2.2, 4, 6" -s "text"
  -b -n 5.0 -l 2.2 -s "more text"
#+END_SRC
**** Output
There is no direct output for this method. Instead, the values of the arguments
can be accessed using the =Parser#[]= operator. For example, below can be seen
the results after calling =Parser#parse= on the first set line of arguments seen
above:
#+BEGIN_SRC ruby
  mybool = parser["b"]    # => true
  mynum = parser["n"]     # => 50
  mynumlist = parser["l"] # => [2,4,6]
  mystring = parser["s"]  # => "text"
#+END_SRC

For arguments which are expected but omitted in the parsed string, the =Parser=
assigns to them default values. See Table ref:tab-default-arg-val for the
default values. For arguments which are unexpected but included in the parsed string,
=Parser#valid?= will return false. Otherwise, =Parser#valid?= will return true.

#+CAPTION: Default argument values
#+ATTR_LATEX: :placement [h]
#+TBLNAME: tab-default-arg-val
| Type        | Default |
|-------------+---------|
| Boolean     | =false= |
| Number      | =0=     |
| Number List | =[]=    |
| String      | ""      |

** Implementation Details
This description of the implementation details of the Ruby Args library will be
given using literate programming.
*** Overview
The implementation of this library is separated into the two public routines,
=Args.expect= and =Parser#parse=:
1) =Args.expect=
   1) Build a hash table of arguments each with a corresponding argument marshaler.
   2) Return a parser containing the resulting hash table.
2) =Parser#parse=
   1) For each argument in the CLI argument list, get the corresponding
      marshaler from the hash table.
      1) Call upon the resulting marshaler to parse the argument's value.
   2) Query the value of the appropriate marshaler to get an argument's value.
*** Argument Declaration
1) Argument declaration begins with =Args.expect= which wraps the calling of the
   =Parser= instance methods, =boolean=, =number=, =string=, and =number_list=.
   1. Each marshaler class, inside its own class declaration, uses the static method
      =Parser.add_declarator= to allow users of the =Parser= class to declare
      arguments of the type that marshaler is concerned with. For example, the
      =BooleanMarshaler= adds the method =Parser#boolean= to the =Parser=
      class, enabling the user of the =Parser= class to declare boolean arguments.
   2. Each of those functions wraps the =Parser#declare arguments= method, which
      stores each declared argument in a hash table along with an instance of
      the appropriate marshaler class (=BooleanMarshaler= for =boolean=,
      =StringMarshaler= for =string=, etc.). At construction, the marshaler sets
      its value to the appropriate default. See Table ref:tab-default-arg-val for
      those defaults.

2) An instance of the =Parser= class prepared with a hash table of expected argument
   marshalers is returned.
*** Parsing
Parsing begins with =Parser#parse= which parses an argument list until it is empty.
1) Parsing an argument entails ensuring the argument is valid and appropriately
   setting the argument's value. The name is valid if and only if its prefix is
   a '-'. Then, the name used in the hash table is the argument excluding the
   '-'. Setting an argument's value entails ensuring that the name to which the
   value is associated exists as a key in the hash table and then calling
   =set_value= on the marshaler associated with that key. If the key is not in
   the hash table, the parser is said to be invalid. 
   1) At this point, the
      marshaler associated with the key is responsible for parsing the value from
      the remaining arguments.
      1) =BoolMarshaler= does not need to parse the remaining
         arguments; it can simply set its value to =true=.
      2) =NumberMarshaler= pops the next string in the arguments array and converts it
         to a float.
      3) =StringMarshaler= pops the next string and copies it. 
      4) =NumberListMarshaler= pops the next string and splits the it into an array of
         smaller strings using ',' as a separator. Then, each of the smaller strings
         are converted to a float and a new array is constructed from those floats in
         the order they appeared in the originally popped string.
2) Accessing the parsed values, then, only requires the user to lookup from the
   hash table the marshaler for the argument he or she is concerned with and
   query its value. This functionality is wrapped by the =Parser#[]= operator.
** Analysis
*** Complexity
=Args.expect= is linear in the number of arguments declared (i.e. adding up the
arguments declared in each declarator call), assuming =Class.eval_module= can be
executed in constant time. Each declarator calls =Parser#declare_arguments=
which is clearly linear in the number of arguments declared.

=Parser#parse= is linear in the total amount of digits to be parsed plus the
length of the CLI arguments list, assuming each string-to-float conversion is
linear in the number of digits to be parsed. =Parser#parse= is clearly a linear
iteration over the CLI arguments list. Each iteration involves visiting an
object with the type of one of the marshalers. The string and boolean marshalers
can both parse their values in constant time, but parsing for the numeric
marshalers involves one or more string-to-float conversions.

*** Practicality
Ruby Args seems to perform adequately. However, practical usage seems to be
restricted to educational use, as, through somewhat trivial stress testing, it
was observed that the case of when the user fails to pass a value to any numeric
argument (e.g. "ruby Main.rb -n", if n is a numeric argument), either a ruby
run-time error would occur, or the library would silently fail, using the
argument's default value after essentially discarding the argument after it,
depending on whether the numeric argument was the last argument given or
not. The former can be fixed by wrapping the =Parser#parse= call in a rescue
block, but the latter is very bad. As most users expect CLI programs to never
silently fail or expose implementation details, users of this library should be
wary.

bibliography:references.bib
